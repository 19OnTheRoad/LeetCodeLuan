87. Scramble String

class Solution {
public:
    bool isScramble(string s1, string s2) {
        unordered_map<string, bool> ump;
        return helper(s1,s2, ump);
    }
    bool helper(string s1, string s2, unordered_map<string, bool>& ump){
        if(ump.count(s1+s2)) return ump[s1+s2];
        bool res = false;
        int n = s1.size();
        if(n == 1) res = s1 == s2;
        else{
            for(int i = 1; i < n; i++){
                res = res || helper(s1.substr(0, i), s2.substr(0, i), ump) && helper(s1.substr(i), s2.substr(i), ump);
                res = res || helper(s1.substr(0, i), s2.substr(n-i), ump) && helper(s1.substr(i), s2.substr(0, n - i), ump);
            }
        }
        return ump[s1+s2] = res;
    }
};



class Solution {
public:
    bool isScramble(string s1, string s2) {
        int n = s1.size(), len, i, j, k;
        if(0==n) return true;
        if(1==n) return s1==s2;
        bool dp[n+1][n][n];  //  whether s1[i..i+len-1] is a scramble of s2[j..j+len-1].
        for(i=0; i<n; ++i)
            for(j=0; j<n; ++j)
                dp[1][i][j] = s1[i] == s2[j];
        for(len=2; len <=n; ++len)
            for(i=0; i<=n-len; ++i)
                for(j=0; j<=n-len; ++j){
                    dp[len][i][j] = false;
                        for(k=1; k<len && !dp[len][i][j]; ++k){
                            dp[len][i][j] = dp[len][i][j] || (dp[k][i][j] && dp[len-k][i+k][j+k]);
                            dp[len][i][j] = dp[len][i][j] || (dp[k][i+len-k][j] && dp[len-k][i][j+k]);
                        }
                }
        return dp[n][0][0];            
    }
}; 

class Solution {
public:
    bool isScramble(string s1, string s2) {
        const int n = s1.size();
        if(0==n) return true;
        char isS[(n+1)*n*n];
        fill_n(isS, (n+1)*n*n, 0);
        return DP_helper(s1, s2, 0, 0, n, isS);
    }
    bool DP_helper(string &s1, string &s2, int idx1, int idx2, int len, char isS[]){
        int n = s1.size(),i, j, k, hist[26] , zero_count =0;
        if(isS[(len*n+idx1)*n+idx2]) return isS[(len*n+idx1)*n+idx2]==1;
        bool res = false;
        
        fill_n(hist, 26, 0);
        for(k=0; k<len;++k){ // check if s1[idx1:idx1+len-1] and s2[idx2:idx2+len-1] have same characters
            zero_count +=  (0==hist[s1[idx1+k]-'a']) - (0== ++hist[s1[idx1+k]-'a']);
            zero_count +=  (0==hist[s2[idx2+k]-'a']) - (0== --hist[s2[idx2+k]-'a']);
        }
        if(zero_count) {isS[(len*n+idx1)*n+idx2] = 2; return false;} //if not, return directly
        if(len==1)     {isS[(len*n+idx1)*n+idx2] = 1; return true;}
        for(k=1;k<len && !res;++k){ //otherwise, recursion with cache
            res = res || (DP_helper(s1, s2, idx1, idx2, k, isS) && DP_helper(s1, s2, idx1+k, idx2+k, len-k, isS) );
            res = res || (DP_helper(s1, s2, idx1+len-k, idx2, k, isS) && DP_helper(s1, s2, idx1, idx2+k, len-k, isS) );
        }
        isS[(len*n+idx1)*n+idx2] = res?1:2;
        return res;
    }
};
